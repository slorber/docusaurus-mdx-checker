"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[508],{1133:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var n=s(4246),a=s(1670);const r={id:"asynchronous",title:"Testing Asynchronous Code"},o=void 0,c={unversionedId:"asynchronous",id:"version-29.6/asynchronous",title:"Testing Asynchronous Code",description:"It's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.",source:"@site/versioned_docs/version-29.6/TestingAsyncCode.md",sourceDirName:".",slug:"/asynchronous",permalink:"/docs/asynchronous",draft:!1,unlisted:!1,editUrl:"https://github.com/jestjs/jest/edit/main/website/versioned_docs/version-29.6/TestingAsyncCode.md",tags:[],version:"29.6",lastUpdatedBy:"Simen Bekkhus",lastUpdatedAt:1690449395,formattedLastUpdatedAt:"Jul 27, 2023",frontMatter:{id:"asynchronous",title:"Testing Asynchronous Code"},sidebar:"docs",previous:{title:"Using Matchers",permalink:"/docs/using-matchers"},next:{title:"Setup and Teardown",permalink:"/docs/setup-teardown"}},i={},d=[{value:"Promises",id:"promises",level:2},{value:"Async/Await",id:"asyncawait",level:2},{value:"Callbacks",id:"callbacks",level:2},{value:"<code>.resolves</code> / <code>.rejects</code>",id:"resolves--rejects",level:2}];function l(e){const t=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",admonition:"admonition",em:"em"},(0,a.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"It's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this."}),"\n",(0,n.jsx)(t.h2,{id:"promises",children:"Promises"}),"\n",(0,n.jsx)(t.p,{children:"Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail."}),"\n",(0,n.jsxs)(t.p,{children:["For example, let's say that ",(0,n.jsx)(t.code,{children:"fetchData"})," returns a promise that is supposed to resolve to the string ",(0,n.jsx)(t.code,{children:"'peanut butter'"}),". We could test it with:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n"})}),"\n",(0,n.jsx)(t.h2,{id:"asyncawait",children:"Async/Await"}),"\n",(0,n.jsxs)(t.p,{children:["Alternatively, you can use ",(0,n.jsx)(t.code,{children:"async"})," and ",(0,n.jsx)(t.code,{children:"await"})," in your tests. To write an async test, use the ",(0,n.jsx)(t.code,{children:"async"})," keyword in front of the function passed to ",(0,n.jsx)(t.code,{children:"test"}),". For example, the same ",(0,n.jsx)(t.code,{children:"fetchData"})," scenario can be tested with:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  expect.assertions(1);\n  try {\n    await fetchData();\n  } catch (e) {\n    expect(e).toMatch('error');\n  }\n});\n"})}),"\n",(0,n.jsxs)(t.p,{children:["You can combine ",(0,n.jsx)(t.code,{children:"async"})," and ",(0,n.jsx)(t.code,{children:"await"})," with ",(0,n.jsx)(t.code,{children:".resolves"})," or ",(0,n.jsx)(t.code,{children:".rejects"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In these cases, ",(0,n.jsx)(t.code,{children:"async"})," and ",(0,n.jsx)(t.code,{children:"await"})," are effectively syntactic sugar for the same logic as the promises example uses."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["Be sure to return (or ",(0,n.jsx)(t.code,{children:"await"}),") the promise - if you omit the ",(0,n.jsx)(t.code,{children:"return"}),"/",(0,n.jsx)(t.code,{children:"await"})," statement, your test will complete before the promise returned from ",(0,n.jsx)(t.code,{children:"fetchData"})," resolves or rejects."]})}),"\n",(0,n.jsxs)(t.p,{children:["If you expect a promise to be rejected, use the ",(0,n.jsx)(t.code,{children:".catch"})," method. Make sure to add ",(0,n.jsx)(t.code,{children:"expect.assertions"})," to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the fetch fails with an error', () => {\n  expect.assertions(1);\n  return fetchData().catch(e => expect(e).toMatch('error'));\n});\n"})}),"\n",(0,n.jsx)(t.h2,{id:"callbacks",children:"Callbacks"}),"\n",(0,n.jsxs)(t.p,{children:["If you don't use promises, you can use callbacks. For example, let's say that ",(0,n.jsx)(t.code,{children:"fetchData"}),", instead of returning a promise, expects a callback, i.e. fetches some data and calls ",(0,n.jsx)(t.code,{children:"callback(null, data)"})," when it is complete. You want to test that this returned data is the string ",(0,n.jsx)(t.code,{children:"'peanut butter'"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["By default, Jest tests complete once they reach the end of their execution. That means this test will ",(0,n.jsx)(t.em,{children:"not"})," work as intended:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"// Don't do this!\ntest('the data is peanut butter', () => {\n  function callback(error, data) {\n    if (error) {\n      throw error;\n    }\n    expect(data).toBe('peanut butter');\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The problem is that the test will complete as soon as ",(0,n.jsx)(t.code,{children:"fetchData"})," completes, before ever calling the callback."]}),"\n",(0,n.jsxs)(t.p,{children:["There is an alternate form of ",(0,n.jsx)(t.code,{children:"test"})," that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called ",(0,n.jsx)(t.code,{children:"done"}),". Jest will wait until the ",(0,n.jsx)(t.code,{children:"done"})," callback is called before finishing the test."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', done => {\n  function callback(error, data) {\n    if (error) {\n      done(error);\n      return;\n    }\n    try {\n      expect(data).toBe('peanut butter');\n      done();\n    } catch (error) {\n      done(error);\n    }\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If ",(0,n.jsx)(t.code,{children:"done()"})," is never called, the test will fail (with timeout error), which is what you want to happen."]}),"\n",(0,n.jsxs)(t.p,{children:["If the ",(0,n.jsx)(t.code,{children:"expect"})," statement fails, it throws an error and ",(0,n.jsx)(t.code,{children:"done()"})," is not called. If we want to see in the test log why it failed, we have to wrap ",(0,n.jsx)(t.code,{children:"expect"})," in a ",(0,n.jsx)(t.code,{children:"try"})," block and pass the error in the ",(0,n.jsx)(t.code,{children:"catch"})," block to ",(0,n.jsx)(t.code,{children:"done"}),". Otherwise, we end up with an opaque timeout error that doesn't show what value was received by ",(0,n.jsx)(t.code,{children:"expect(data)"}),"."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["Jest will throw an error, if the same test function is passed a ",(0,n.jsx)(t.code,{children:"done()"})," callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests."]})}),"\n",(0,n.jsxs)(t.h2,{id:"resolves--rejects",children:[(0,n.jsx)(t.code,{children:".resolves"})," / ",(0,n.jsx)(t.code,{children:".rejects"})]}),"\n",(0,n.jsxs)(t.p,{children:["You can also use the ",(0,n.jsx)(t.code,{children:".resolves"})," matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', () => {\n  return expect(fetchData()).resolves.toBe('peanut butter');\n});\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Be sure to return the assertion\u2014if you omit this ",(0,n.jsx)(t.code,{children:"return"})," statement, your test will complete before the promise returned from ",(0,n.jsx)(t.code,{children:"fetchData"})," is resolved and then() has a chance to execute the callback."]}),"\n",(0,n.jsxs)(t.p,{children:["If you expect a promise to be rejected, use the ",(0,n.jsx)(t.code,{children:".rejects"})," matcher. It works analogically to the ",(0,n.jsx)(t.code,{children:".resolves"})," matcher. If the promise is fulfilled, the test will automatically fail."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"test('the fetch fails with an error', () => {\n  return expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,n.jsx)(t.p,{children:"None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler."})]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,n.jsx)(t,Object.assign({},e,{children:(0,n.jsx)(l,e)})):l(e)}},1670:(e,t,s)=>{s.d(t,{Zo:()=>c,ah:()=>r});var n=s(7378);const a=n.createContext({});function r(e){const t=n.useContext(a);return n.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const o={};function c({components:e,children:t,disableParentContext:s}){let c;return c=s?"function"==typeof e?e({}):e||o:r(e),n.createElement(a.Provider,{value:c},t)}}}]);