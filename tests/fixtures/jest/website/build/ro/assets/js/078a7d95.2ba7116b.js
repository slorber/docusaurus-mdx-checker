"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[3772],{6067:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=n(4246),s=n(1670);const r={id:"asynchronous",title:"Testarea codului asincron"},c=void 0,i={unversionedId:"asynchronous",id:"version-29.5/asynchronous",title:"Testarea codului asincron",description:"Se \xeent\xe2mpl\u0103 frecvent \xeen JavaScript s\u0103 se execute cod asincron. Atunci c\xe2nd ave\u0163i cod care se execut\u0103 \xeen mod asincron, Jest trebuie s\u0103 \u015ftie c\xe2nd codul pe care-l testeaz\u0103 s-a completat de executat, \xeenainte de a trece la un alt test. Jest are mai multe moduri pentru a rezolva acest lucru.",source:"@site/i18n/ro/docusaurus-plugin-content-docs/version-29.5/TestingAsyncCode.md",sourceDirName:".",slug:"/asynchronous",permalink:"/ro/docs/29.5/asynchronous",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/ro",tags:[],version:"29.5",frontMatter:{id:"asynchronous",title:"Testarea codului asincron"},sidebar:"docs",previous:{title:"Utilizarea regulilor de potrivire",permalink:"/ro/docs/29.5/using-matchers"},next:{title:"Asamblare \u0219i dezasamblare",permalink:"/ro/docs/29.5/setup-teardown"}},o={},l=[{value:"Promisiuni",id:"promisiuni",level:2},{value:"Async/Await",id:"asyncawait",level:2},{value:"Callback-uri",id:"callback-uri",level:2},{value:"<code>.resolves</code> / <code>.rejects</code>",id:"resolves--rejects",level:2}];function d(e){const t=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",admonition:"admonition",em:"em"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Se \xeent\xe2mpl\u0103 frecvent \xeen JavaScript s\u0103 se execute cod asincron. Atunci c\xe2nd ave\u0163i cod care se execut\u0103 \xeen mod asincron, Jest trebuie s\u0103 \u015ftie c\xe2nd codul pe care-l testeaz\u0103 s-a completat de executat, \xeenainte de a trece la un alt test. Jest are mai multe moduri pentru a rezolva acest lucru."}),"\n",(0,a.jsx)(t.h2,{id:"promisiuni",children:"Promisiuni"}),"\n",(0,a.jsx)(t.p,{children:"Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail."}),"\n",(0,a.jsxs)(t.p,{children:["For example, let's say that ",(0,a.jsx)(t.code,{children:"fetchData"})," returns a promise that is supposed to resolve to the string ",(0,a.jsx)(t.code,{children:"'peanut butter'"}),". We could test it with:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n"})}),"\n",(0,a.jsx)(t.h2,{id:"asyncawait",children:"Async/Await"}),"\n",(0,a.jsxs)(t.p,{children:["Alternativ, pute\u0163i utiliza ",(0,a.jsx)(t.code,{children:"async"})," \u015fi ",(0,a.jsx)(t.code,{children:"await"})," \xeen teste. To write an async test, use the ",(0,a.jsx)(t.code,{children:"async"})," keyword in front of the function passed to ",(0,a.jsx)(t.code,{children:"test"}),". De exemplu, acela\u015fi scenariu ",(0,a.jsx)(t.code,{children:"fetchData"})," poate fi testat cu:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  expect.assertions(1);\n  try {\n    await fetchData();\n  } catch (e) {\n    expect(e).toMatch('error');\n  }\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You can combine ",(0,a.jsx)(t.code,{children:"async"})," and ",(0,a.jsx)(t.code,{children:"await"})," with ",(0,a.jsx)(t.code,{children:".resolves"})," or ",(0,a.jsx)(t.code,{children:".rejects"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In these cases, ",(0,a.jsx)(t.code,{children:"async"})," and ",(0,a.jsx)(t.code,{children:"await"})," are effectively syntactic sugar for the same logic as the promises example uses."]}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsxs)(t.p,{children:["Be sure to return (or ",(0,a.jsx)(t.code,{children:"await"}),") the promise - if you omit the ",(0,a.jsx)(t.code,{children:"return"}),"/",(0,a.jsx)(t.code,{children:"await"})," statement, your test will complete before the promise returned from ",(0,a.jsx)(t.code,{children:"fetchData"})," resolves or rejects."]})}),"\n",(0,a.jsxs)(t.p,{children:["If you expect a promise to be rejected, use the ",(0,a.jsx)(t.code,{children:".catch"})," method. Asigura\u0163i-v\u0103 c\u0103 utiliza\u021bi ",(0,a.jsx)(t.code,{children:"expect.assertions"})," pentru a verifica c\u0103 un anumit num\u0103r de aser\u021biuni sunt executate. Otherwise, a fulfilled promise would not fail the test."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the fetch fails with an error', () => {\n  expect.assertions(1);\n  return fetchData().catch(e => expect(e).toMatch('error'));\n});\n"})}),"\n",(0,a.jsx)(t.h2,{id:"callback-uri",children:"Callback-uri"}),"\n",(0,a.jsxs)(t.p,{children:["If you don't use promises, you can use callbacks. For example, let's say that ",(0,a.jsx)(t.code,{children:"fetchData"}),", instead of returning a promise, expects a callback, i.e. fetches some data and calls ",(0,a.jsx)(t.code,{children:"callback(null, data)"})," when it is complete. You want to test that this returned data is the string ",(0,a.jsx)(t.code,{children:"'peanut butter'"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["By default, Jest tests complete once they reach the end of their execution. That means this test will ",(0,a.jsx)(t.em,{children:"not"})," work as intended:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// Don't do this!\ntest('the data is peanut butter', () => {\n  function callback(error, data) {\n    if (error) {\n      throw error;\n    }\n    expect(data).toBe('peanut butter');\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Problema este c\u0103 testul se va termina de \xeendat\u0103 ce ",(0,a.jsx)(t.code,{children:"fetchData"})," \xee\u0219i termin\u0103 execu\u021bia, \xeenainte de a apela vreodat\u0103 callback-ul."]}),"\n",(0,a.jsxs)(t.p,{children:["Exist\u0103 o form\u0103 alternativ\u0103 de ",(0,a.jsx)(t.code,{children:"test"})," care rezolv\u0103 acest lucru. \xcen loc de a pune testul \xeentr-o func\u0163ie cu un argument gol, utiliza\u0163i un singur argument numit ",(0,a.jsx)(t.code,{children:"done"}),". Jest va a\u015ftepta p\xe2n\u0103 c\xe2nd func\u021bia ",(0,a.jsx)(t.code,{children:"done"})," este apelat\u0103 \xeenainte de terminarea testului."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', done => {\n  function callback(error, data) {\n    if (error) {\n      done(error);\n      return;\n    }\n    try {\n      expect(data).toBe('peanut butter');\n      done();\n    } catch (error) {\n      done(error);\n    }\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If ",(0,a.jsx)(t.code,{children:"done()"})," is never called, the test will fail (with timeout error), which is what you want to happen."]}),"\n",(0,a.jsxs)(t.p,{children:["If the ",(0,a.jsx)(t.code,{children:"expect"})," statement fails, it throws an error and ",(0,a.jsx)(t.code,{children:"done()"})," is not called. If we want to see in the test log why it failed, we have to wrap ",(0,a.jsx)(t.code,{children:"expect"})," in a ",(0,a.jsx)(t.code,{children:"try"})," block and pass the error in the ",(0,a.jsx)(t.code,{children:"catch"})," block to ",(0,a.jsx)(t.code,{children:"done"}),". Otherwise, we end up with an opaque timeout error that doesn't show what value was received by ",(0,a.jsx)(t.code,{children:"expect(data)"}),"."]}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsxs)(t.p,{children:["Jest will throw an error, if the same test function is passed a ",(0,a.jsx)(t.code,{children:"done()"})," callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests."]})}),"\n",(0,a.jsxs)(t.h2,{id:"resolves--rejects",children:[(0,a.jsx)(t.code,{children:".resolves"})," / ",(0,a.jsx)(t.code,{children:".rejects"})]}),"\n",(0,a.jsxs)(t.p,{children:["You can also use the ",(0,a.jsx)(t.code,{children:".resolves"})," matcher in your expect statement, and Jest will wait for that promise to resolve. \xcen cazul \xeen care promisiunea este respins\u0103, testul va e\u015fua automat."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the data is peanut butter', () => {\n  return expect(fetchData()).resolves.toBe('peanut butter');\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Be sure to return the assertion\u2014if you omit this ",(0,a.jsx)(t.code,{children:"return"})," statement, your test will complete before the promise returned from ",(0,a.jsx)(t.code,{children:"fetchData"})," is resolved and then() has a chance to execute the callback."]}),"\n",(0,a.jsxs)(t.p,{children:["If you expect a promise to be rejected, use the ",(0,a.jsx)(t.code,{children:".rejects"})," matcher. Func\u021bioneaz\u0103 exact ca validatorul ",(0,a.jsx)(t.code,{children:".resolves"}),". \xcen cazul \xeen care promisiunea este \xeendeplinit\u0103, testul va e\u015fua automat."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"test('the fetch fails with an error', () => {\n  return expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler."})]})}const u=function(e={}){const{wrapper:t}=Object.assign({},(0,s.ah)(),e.components);return t?(0,a.jsx)(t,Object.assign({},e,{children:(0,a.jsx)(d,e)})):d(e)}},1670:(e,t,n)=>{n.d(t,{Zo:()=>i,ah:()=>r});var a=n(7378);const s=a.createContext({});function r(e){const t=a.useContext(s);return a.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const c={};function i({components:e,children:t,disableParentContext:n}){let i;return i=n?"function"==typeof e?e({}):e||c:r(e),a.createElement(s.Provider,{value:i},t)}}}]);